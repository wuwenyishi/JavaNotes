



一个分布式系统所涉及到的节点越多，业务越复杂那么出现问题的几率就会越高。网络的不可靠、节点宕机、 程序崩溃，这些意外是无法避免的，结果把系统进行拆分之后反而降低了系统的可用性，这个结果是与我们分布式系统的初衷相背离的，所以我们也就必须要在这些无法避免的意外发生之前，做一些有意识的防范措施，而系统容错就是我们需要下手的第一个方面，系统容错是在发生意外情况下如何尽全力的保证系统可用性的一种方案。

  

## **容错处理的两个方向**


我们应该怎么设计才能在发生错误时候尽量保证系统的可用性呢，我们可以从下面两个方向着手。

**具备保护能力：**在系统发生故障时，我们首先要做的就是避免错误的范围扩大，在一个节点发生错误时如何避免其相关依赖的节点受牵连，从而产生雪崩效应，比如说为请求设置超时时间、隔离错误的节点，这都是对系统的一种保护机制。

**具备修复能力：**在保护故障范围不再扩大的前提，我们再考虑在发生故障的时候如何尽量的保证业务的正确执行，此时我们就需要通过提升系统的自我修复能力来保证系统的可用性了，比如说可以把请求转移正常的节点、做一些适当的重试、或做一些补偿性的措施来保证业务的正常运行。

  

  

## **容错策略**


有了方向之后，我们需要根据具体的情况去制定对应的策略了，下面我们看下在发生错误时候，我们在对应的业务场景可以使用什么样的容错策略。

  

## **故障转移**

核心目标：发生错误时，尽最大努力保证系统的可用性。

故障转移策略是在集群情况下，如果向一个节点请求错误时，会对另外一个节点重试发送请求，从而保证在某些节点出现问题时，系统还能正常的提供服务，从而提高系统服务的可用性。

需要注意的问题：

1、如果整个集群大多数节点都有问题时，那么此时重试次数会过多，而且没有太大意义，所以我们需要设定重试次数，避免没有意义的一直重试。

2、不具备幂等性的请求不能采用重试机制，因为网络的不确定性，一旦前一个被认为失败了的请求，和后一个重试的请求都成功到达服务器了，那么就会造成同样的业务会被执行两次，此时请求不具备幂等性就会产生业务问题，所以采用重试机制的前提是请求要具备幂等性。

  

### **故障恢复**

核心目标： 发生错误时，尽最大努力完成工作。

当请求失败时，后台进行记录，然后系统定时的进行请求的重试，从而尽最大努力保证业务会被执行。

需要注意：重试的请求必须具备幂等性。

适合场景： 发送消息或者通知。

  

  

### **快速失败**

核心目标：发生错误时，尽量保证数据的正确性。

上面我们已经提到了，如果请求不具备幂等性时，我们对请求进行重试可能会出现业务问题，所以对于不具备幂等性的请求我们采用的策略是快速失败，快速失败就是在出现错误时，什么都不做，直接向客户端响应错误，而不进行任何重试处理。

适合场景： 请求不具备幂等性的场景。

  

### **沉默失败**

核心目标：发生错误时，尽量减少错误的节点对后续请求的影响范围。

前面的人在路上摔跤了，就会提醒后面的同志这条路不好走，这样后面的人就会尽量改换其它的路通过，避免踩同样的坑。沉默失败策略思路与之类似，当一个节点请求失败时候，会对该节点进行标记，被标记的一定时间内，请求不会发送到该节点。

  

  

### **安全失败**

核心目标：发生错误时， 尽量保证核心工作的完成。

当一个请求牵扯到多个业务调用时，如果可以忽略非核心业务的错误，只要核心业务不错则可以响应成功，尽量保证非核心业务不影响。

适合场景：不重要的业务，比如：记日志。

  

  

### **并行调用**

核心目标：尽量保证性能

在发起请求时，向集群的多个节点同时发起调用，只要一个节点成功返回则响应客户端，这种策略保证了以最快速度响应客户端，同时在某些节点发生故障也可以提高请求的成功几率。

需要注意： 并行调用的请求必须具备幂等性。

适合场景：追求实时性高的场景

  

  

### **广播调用**

核心目标： 所有请求成功才能算成功。

在发起请求时，向集群的多个节点同时发起调用，当所有节点都返回成功时才向客户端返回成功。

适用场景： 多个节点需要保证一致性的场景，比如数据同步、分布式事务、缓存更新。

  

  

  

## **容错模式应用**


在了解了这么多容错策略后，我们需要做的是，如何把这些容错策略落地实现到我们的系统里面去，根据不同的业务场景制定和组合不同的策略来保证系统的可用性，实践过后也就形成了一些通用的容错设计模式，比如说断路器模式、重试模式、舱壁隔离模式 等。

  

### **断路器模式**

在分布式环境下，调用某个服务发生错误时，为了避免继续影响后续的请求导致导致雪崩效应，所以需要在发生错误时，当满足某种条件下，系统有直接阻断调用后续服务的能力，断路器的核心思想就是通过熔断机制为系统提供 “保护能力”。

  

**实现断路器主要包括以下几个关键点**

1、代理： 断路器在服务与服务调用过程中充当代理的角色，请求方和断路器交互，然后由断路器与实际的服务交互。

![](https://cdn.jsdelivr.net/gh/wuwenyishi/shared@image/2022/04/07/1138-ZvWtcU.jpg)

  

2、错误计数器：断路器里维护了几个计数器，来进行请求成功失败情况的记录。 不同类型的错误（失败、超时、拒绝）分别有着对应类型的计数器，后续会根据这些计数器统计分析来进行断路器的状态变更。

3、断路器状态： 当某种类型的计数器到达阈值时，就会触发断路器状态（关闭、打开、半开）的变更，当断路器状态变更后，断路器会对请求进行不同方式的处理。

  

**断路器的整体逻辑**

断路器分为关闭、打开、半打开几种状态， 默认是关闭状态.，当一定时间内错误次数达到某个阈值，那么断路器就会"打开"状态，断路器打开之后所有请求都将直接返回失败，之后经过一段时间或者一定数量的请求之后，断路器会进入“半开”状态,在半开状态下，断路器会方向一定数量的请求，然后根据这些请求的响应情况来决定是进入“关闭”状态还是“打开状态”。

![](https://cdn.jsdelivr.net/gh/wuwenyishi/shared@image/2022/04/07/1138-RPqYuF.jpg)

  

### **重试模式**

因为网络的不可靠，所以必然会产生某些请求因为网络问题而失败，而这样的情况通常是偶发性的，并且不是因为系统本身的故障导致，所以面对这样的问题，我们通常可以通过重试来保证请求的正常处理，在请求失败的时，我们可以通过进行一定次数的重试，在不稳定的网络环境下重试模式可以尽最大的能力成功请求，从而提升系统可用性。

  

重试模式本事实现比较简单，当请求发生错误的时候，再重新发送一个请求。不过实现重试模式有几个需要注意的地方。

1、首先重试的请求必须具备幂等性，因为重试可能导致向服务端发送多个请求，如果请求不具备幂等性的话就会产生业务错误。在HTTP请求规范里，GET请求具备幂等性，而POST、PUT、DELETE都不具备幂等性。

2、对于什么类型的错误才进行重试，通常我们会对网络超时的请求进行重试，但有某些明显业务含义的请求重试是没有意义的（比如404找不到服务，401没有权限，403拒绝服务）。

3、必须要有超时时间和次数，不能一直无限的进行重试，这样会浪费资源。 要设定超时时间，特别对于上游有超时时间的情况下，如果上游超时时间为3秒，超过3秒后上游的客户端已经中断了请求，那么再继续重试也是没有意义的。

  

  

### **舱壁隔离模式**

舱壁隔离模式的思想来源于我们的轮船设计，在设计船舶的时候，我们会用舱壁把船舶对各个船舱进行隔离，这样的话在我们的轮船某一个船舱进水后，让水不会进入到其它的船舱。舱壁隔离模式的核心思想在于，使用资源隔离的方式避免因为局部问题而导致的系统整体性问题。

舱壁隔离模式的核心在于隔离， 隔离的目的也是避免相互影响，通常像Tomcat 这样的HTTP容器，通常会创建一个线程池，收到一个HTTP请求之后就会使用一个线程去处理对应的业务。假如我们系统有下单和发送短信两个业务， 如果两个业务使用同一个线程池的话，那么当 发送短信的时候发生故障，导致短信业务阻塞占用线程资源无法释放，这样的话本来正常的下单业务也会因为分配不到线程资源，从而导致系统下单的业务也无法正常使用。

所以为我们可以通过隔离不同业务的线程池，来避免业务之间相互影响，下单业务和短信业务分别创建两个不同的线程池，然后对应业务也只会用自己的线程池资源处理对应业务，在这样的模式下，当某一个业务激增或者故障阻塞，能影响的也只有对应的业务，不会对整个系统产生影响，从而保证系统的可用性。

  

虽然舱壁隔离模名字显得生疏，但是其思想在很多场景都在应用，比如异地多活的架构，通过DNS来把不同地区的流量转发到对应地区的服务器，这样就保证了某一个地区的服务器产生故障后，其它地区的人依然可以正常的使用系统。还有在操作系统层面，每个应用的内存空间都是独立的，在某一个应用发生内存溢出时，其它应用并不会因此而受到影响。

  

> 本文转自 [https://zhuanlan.zhihu.com/p/488337839](https://zhuanlan.zhihu.com/p/488337839)，如有侵权，请联系删除。